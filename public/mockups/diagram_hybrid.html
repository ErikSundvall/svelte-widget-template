<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Vega Lite Config + D3 Rendering Diagram</title>
    <script src="../js/lib/d3.v7.min.js"></script>
    <style>
        /* Layout and container styles */
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
        }

        #test-container {
            position: absolute;
            top: 20px;
            bottom: 20px;
            left: 20px;
            right: 20px;
            border: 2px dashed #999;
            background: white;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            border-radius: 4px;
        }

        #test-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-align: center;
        }

        #chart-container {
            flex-grow: 1;
            position: relative;
            min-height: 0;
            width: 100%;
        }

        /* Tooltip styles - position and layout only, colors from config */
        .tooltip {
            position: absolute;
            text-align: left;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 20;
            line-height: 1.4;
        }

        /* Crosshair - opacity and pointer events only, stroke from config */
        .crosshair {
            pointer-events: none;
            opacity: 0;
        }

        /* Axis color classes for specific axes (kept for backwards compatibility) */
        .axis.axis-blue text {
            fill: #0077be;
        }

        .axis.axis-blue path,
        .axis.axis-blue line {
            stroke: #0077be;
            opacity: 0.5;
        }

        .axis.axis-red text {
            fill: #e63946;
        }

        .axis.axis-red path,
        .axis.axis-red line {
            stroke: #e63946;
            opacity: 0.5;
        }

        .axis.axis-green text {
            fill: #06a77d;
        }

        .axis.axis-green path,
        .axis.axis-green line {
            stroke: #06a77d;
            opacity: 0.5;
        }

        /* Grid rendering */
        .grid line {
            shape-rendering: crispEdges;
        }
    </style>
</head>

<body>

    <div id="test-container">
        <div id="test-label">Hybrid: Vega Lite-style Config + D3 Mockup Rendering (Resize Window to Test)</div>
        <div id="chart-container"></div>
    </div>
    <div id="tooltip" class="tooltip"></div>

    <script>
        // ============================================================================
        // VEGA LITE-STYLE DECLARATIVE CONFIGURATION
        // ============================================================================
        // NOTE: This is a hybrid approach using Vega Lite-inspired declarative JSON
        // configuration with custom D3 rendering. The structure uses standard Vega Lite
        // types where possible (e.g., "line", "point") rather than custom types.
        //
        // Data Structure for Multiple Values at Same Timepoint:
        // Instead of nested structures like { time: t, systolic: {...}, diastolic: {...} },
        // we use separate series arrays with the same timepoints:
        //   - systolic: [{ time: t1, value: 120 }, { time: t2, value: 125 }, ...]
        //   - diastolic: [{ time: t1, value: 80 }, { time: t2, value: 85 }, ...]
        // This aligns better with standard visualization patterns and prepares for
        // openEHR OBSERVATION instances that can have multiple values at the same timepoint.
        const spec = {
            "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
            "description": "Health metrics visualization with responsive design and Voronoi interactions",
            "config": {
                "margin": { "top": 20, "right": 40, "bottom": 70, "left": 40 },
                "trackGaps": 20,
                "axisGap": 10,
                "style": {
                    "axis": {
                        "labelFontSize": 11,
                        "labelFontWeight": "bold",
                        "tickFontSize": 10,
                        "tickColor": "#666",
                        "domainColor": "#ddd",
                        "gridColor": "#f5f5f5"
                    },
                    "legend": {
                        "fontSize": 10,
                        "textColor": "#555"
                    },
                    "crosshair": {
                        "stroke": "#999",
                        "strokeWidth": 1,
                        "strokeDasharray": "4,2"
                    },
                    "tooltip": {
                        "fontSize": 11,
                        "padding": 8,
                        "background": "rgba(0, 0, 0, 0.9)",
                        "textColor": "white",
                        "borderRadius": 4
                    }
                }
            },
            "data": {
                "generator": "time-series",
                "hours": 60,
                "startTime": "now"
            },
            "tracks": [
                {
                    "weight": 0.7,
                    "title": "Temperature",
                    "axes": [
                        {
                            "position": "left",
                            "domain": null,
                            "label": "Temp °C",
                            "color": "#e63946",
                            "ticks": 5
                        }
                    ],
                    "series": [
                        {
                            "type": "line",
                            "data": "temp",
                            "axis": "left",
                            "color": "#e63946",
                            "strokeWidth": 2,
                            "curve": "monotoneX",
                            "showPoints": true,
                            "pointStyle": {
                                "fill": "white",
                                "stroke": "#e63946",
                                "strokeWidth": 2,
                                "radius": 3
                            }
                        }
                    ]
                },
                {
                    "weight": 1,
                    "title": "Oxygenation & Respiration",
                    "axes": [
                        {
                            "position": "left",
                            "domain": [10, 30],
                            "label": "Resp /min",
                            "color": "#06a77d",
                            "ticks": 5
                        },
                        {
                            "position": "right",
                            "domain": [80, 100],
                            "label": "SpO2 %",
                            "color": "#0077be",
                            "ticks": 5
                        }
                    ],
                    "series": [
                        {
                            "type": "line",
                            "data": "respiration",
                            "axis": "left",
                            "color": "#06a77d",
                            "strokeWidth": 2,
                            "curve": "monotoneX",
                            "showPoints": true,
                            "pointStyle": {
                                "fill": "white",
                                "stroke": "#06a77d",
                                "strokeWidth": 2,
                                "radius": 3
                            }
                        },
                        {
                            "type": "line",
                            "data": "spo2",
                            "axis": "right",
                            "color": "#0077be",
                            "strokeWidth": 2,
                            "strokeDasharray": "4,2",
                            "curve": "monotoneX"
                        }
                    ]
                },
                {
                    "weight": 2,
                    "title": "Blood Pressure & Pulse",
                    "axes": [
                        {
                            "position": "left",
                            "domain": [40, 160],
                            "label": "",
                            "ticks": 6
                        }
                    ],
                    "legend": {
                        "items": [
                            {"symbol": "v", "color": "#457b9d", "label": "Systolic"},
                            {"symbol": "v-inv", "color": "#1d3557", "label": "Diastolic"},
                            {"symbol": "circle", "color": "#e63946", "label": "Pulse (BP)"},
                            {"symbol": "circle-filled", "color": "#e63946", "label": "Pulse (Oximeter)"}
                        ]
                    },
                    "series": [
                        {
                            "type": "point",
                            "data": "systolic",
                            "axis": "left",
                            "color": "#457b9d",
                            "symbol": "v",
                            "connectTo": "diastolic"
                        },
                        {
                            "type": "point",
                            "data": "diastolic",
                            "axis": "left",
                            "color": "#1d3557",
                            "symbol": "v-inv"
                        },
                        {
                            "type": "point",
                            "data": "pulseBP",
                            "axis": "left",
                            "color": "#e63946",
                            "symbol": "circle",
                            "hollow": true
                        },
                        {
                            "type": "point",
                            "data": "pulseOx",
                            "axis": "left",
                            "color": "#e63946",
                            "symbol": "circle",
                            "hollow": false
                        }
                    ]
                },
                {
                    "weight": 0.5,
                    "title": "Wellbeing",
                    "axes": [
                        {
                            "position": "left",
                            "domain": [0.5, 5.5],
                            "label": "Wellbeing",
                            "ticks": [1, 2, 3, 4, 5],
                            "gridLines": [0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
                        }
                    ],
                    "series": [
                        {
                            "type": "categorical",
                            "data": "wellbeing",
                            "axis": "left",
                            "colorScale": {
                                "domain": [1, 2, 3, 4, 5],
                                "range": ["#d62828", "#f77f00", "#fcbf49", "#aacc00", "#2a9d8f"]
                            },
                            "barWidth": 12,
                            "barRadius": 2
                        }
                    ]
                }
            ]
        };

        // ============================================================================
        // DATA GENERATOR (from mockup)
        // ============================================================================
        function generateData(config) {
            const now = new Date();
            const hours = config.data.hours || 60;
            const times = d3.range(hours).map(i => new Date(now.getTime() - (hours - i) * 3600 * 1000));
            const fewerTimes = d3.range(0, hours, 4).map(i => new Date(now.getTime() - (hours - i) * 3600 * 1000));

            // Temperature with reduced variation - more realistic
            const tempData = times.map(t => ({
                time: t, 
                value: 36.8 + Math.sin(t.getTime() / 20000000) * 0.3 + (Math.random() * 0.2 - 0.1), 
                unit: '°C', 
                type: 'Temp'
            }));

            // Pulse oximeter measurements - dense when monitoring, with gaps during meals/breaks
            // Generate monitoring periods with 5-minute intervals, interspersed with gaps
            const oximeterTimepoints = [];
            let currentTime = 0;
            
            while (currentTime < hours) {
                // Monitoring period: 30-120 minutes of continuous monitoring
                const monitoringDuration = 30 + Math.floor(Math.random() * 90);
                const monitoringEnd = Math.min(currentTime + monitoringDuration, hours);
                
                // Add measurements every 5 minutes during monitoring
                for (let i = currentTime; i < monitoringEnd; i += 5/60) {
                    if (i < hours) {
                        oximeterTimepoints.push(new Date(now.getTime() - (hours - i) * 3600 * 1000));
                    }
                }
                
                currentTime = monitoringEnd;
                
                // Gap period: 30-120 minutes (meals, breaks, etc.)
                if (currentTime < hours) {
                    const gapDuration = 30 + Math.floor(Math.random() * 90);
                    currentTime += gapDuration;
                }
            }
            
            const spo2Data = oximeterTimepoints.map(t => {
                let val = 96 + Math.random() * 3; 
                if (Math.random() < 0.05) val -= Math.random() * 8; 
                val = Math.max(88, Math.min(100, val));
                return { time: t, value: val, unit: '%', type: 'SpO2' };
            });

            const respirationData = oximeterTimepoints.map(t => {
                const respVal = Math.round(13 + Math.random() * 6);
                return { time: t, value: respVal, unit: '/min', type: 'Respiration' };
            });

            const pulseOxData = oximeterTimepoints.map(t => {
                const pulseVal = Math.round(66 + Math.random() * 12);
                return { time: t, value: pulseVal, unit: '/min', type: 'Pulse (Oximeter)' };
            });

            // Blood pressure measurements - separate timing, includes pulse from BP machine
            const bpTimepoints = fewerTimes.filter(() => Math.random() <= 0.6);
            
            const systolicData = bpTimepoints.map((t) => {
                const sys = Math.round(120 + Math.random() * 20 - 10);
                return { time: t, value: sys, unit: 'mm[Hg]', type: 'Systolic' };
            });

            const diastolicData = bpTimepoints.map((t) => {
                const dia = Math.round(80 + Math.random() * 10 - 5);
                return { time: t, value: dia, unit: 'mm[Hg]', type: 'Diastolic' };
            });

            const pulseBPData = bpTimepoints.map((t) => {
                const pulseVal = Math.round(70 + Math.random() * 10);
                return { time: t, value: pulseVal, unit: '/min', type: 'Pulse (BP)' };
            });

            const wellbeingData = times.map(t => {
                if (Math.random() > 0.4) return null;
                return { time: t, value: Math.floor(Math.random() * 5) + 1, unit: 'score', type: 'Wellbeing' };
            }).filter(d => d);

            return { 
                temp: tempData, 
                spo2: spo2Data, 
                respiration: respirationData,
                systolic: systolicData, 
                diastolic: diastolicData, 
                pulseBP: pulseBPData,
                pulseOx: pulseOxData,
                wellbeing: wellbeingData, 
                times 
            };
        }

        // ============================================================================
        // D3 RENDERER (from mockup line 131 onwards)
        // ============================================================================
        function renderChart(containerWidth, containerHeight) {
            d3.select("#chart-container").selectAll("*").remove();

            const data = generateData(spec);
            const margin = spec.config.margin;
            const trackGaps = spec.config.trackGaps;
            const axisGap = spec.config.axisGap;

            // Calculate Dimensions
            const fullWidth = containerWidth;
            const fullHeight = containerHeight;
            const contentWidth = fullWidth - margin.left - margin.right;
            const contentHeight = fullHeight - margin.top - margin.bottom - axisGap;

            if (contentWidth < 0 || contentHeight < 0) return;

            // Dynamic Track Heights
            const trackWeights = spec.tracks.map(t => t.weight);
            const totalWeight = trackWeights.reduce((a, b) => a + b, 0);
            const availableTrackSpace = contentHeight - (trackWeights.length - 1) * trackGaps;
            const trackHeights = trackWeights.map(w => (w / totalWeight) * availableTrackSpace);

            // X Scale
            const x = d3.scaleTime().domain(d3.extent(data.times)).range([0, contentWidth]);
            const formatFullTime = d3.timeFormat("%Y-%m-%d %H:%M");

            // SVG
            const svg = d3.select("#chart-container")
                .append("svg")
                .attr("width", fullWidth)
                .attr("height", fullHeight)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Define Gradient for Sticky Date
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "fade-left")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");
            gradient.append("stop").attr("offset", "0%").attr("style", "stop-color:#eef;stop-opacity:0");
            gradient.append("stop").attr("offset", "30%").attr("style", "stop-color:#eef;stop-opacity:1");
            gradient.append("stop").attr("offset", "100%").attr("style", "stop-color:#eef;stop-opacity:1");

            let currentY = 0;
            let voronoiPoints = [];
            const pushVoronoi = (time, value, yOffset, yScale, data, label) => {
                voronoiPoints.push({ x: x(time), y: yOffset + yScale(value), data, label, time: time });
            };

            // Render each track
            spec.tracks.forEach((trackSpec, trackIndex) => {
                const height = trackHeights[trackIndex];
                const g = svg.append("g").attr("transform", `translate(0, ${currentY})`);

                // Create scales for this track
                const scales = {};
                trackSpec.axes.forEach(axis => {
                    let domain = axis.domain;
                    
                    // Auto-calculate domain if null (Vega Lite style)
                    if (domain === null) {
                        // Find all series using this axis and calculate min/max
                        const seriesForAxis = trackSpec.series.filter(s => s.axis === axis.position);
                        const allValues = [];
                        
                        seriesForAxis.forEach(series => {
                            const seriesData = data[series.data];
                            if (seriesData) {
                                seriesData.forEach(d => {
                                    if (d && d.value !== undefined && d.value !== null) {
                                        allValues.push(d.value);
                                    }
                                });
                            }
                        });
                        
                        if (allValues.length > 0) {
                            const min = d3.min(allValues);
                            const max = d3.max(allValues);
                            const padding = (max - min) * 0.1; // 10% padding
                            domain = [min - padding, max + padding];
                        } else {
                            domain = [0, 1]; // Fallback
                        }
                    }
                    
                    scales[axis.position] = d3.scaleLinear()
                        .domain(domain)
                        .range([height, 0]);
                });

                // Grid (use first axis)
                const firstAxis = trackSpec.axes[0];
                const gridScale = scales[firstAxis.position];
                const gridGroup = g.append("g").attr("class", "grid")
                    .call(d3.axisLeft(gridScale)
                        .tickValues(firstAxis.gridLines || null)
                        .ticks(firstAxis.ticks || 5)
                        .tickSize(-contentWidth)
                        .tickFormat(""));
                
                // Apply grid color from config
                if (spec.config.style?.axis?.gridColor) {
                    gridGroup.selectAll("line").attr("stroke", spec.config.style.axis.gridColor);
                }

                // Render axes
                trackSpec.axes.forEach(axis => {
                    const yScale = scales[axis.position];
                    let colorClass = '';
                    if (axis.color === '#0077be') colorClass = 'blue';
                    else if (axis.color === '#e63946') colorClass = 'red';
                    else if (axis.color === '#06a77d') colorClass = 'green';
                    const axisClass = `axis ${colorClass ? `axis-${colorClass}` : ''}`;
                    
                    if (axis.position === 'left') {
                        const axL = g.append("g").attr("class", axisClass)
                            .call(d3.axisLeft(yScale)
                                .tickValues(axis.ticks && Array.isArray(axis.ticks) ? axis.ticks : null)
                                .ticks(axis.ticks && typeof axis.ticks === 'number' ? axis.ticks : 5)
                                .tickSize(axis.gridLines ? 0 : undefined));
                        
                        // Apply axis styles from config if no color specified
                        if (!colorClass && spec.config.style?.axis) {
                            axL.selectAll("text").attr("font-size", spec.config.style.axis.tickFontSize);
                            if (!axis.color) {
                                axL.selectAll("text").attr("fill", spec.config.style.axis.tickColor);
                                axL.selectAll("path, line").attr("stroke", spec.config.style.axis.domainColor);
                            }
                        }
                        
                        if (axis.label) {
                            axL.append("text").attr("class", "axis-label")
                                .attr("transform", "rotate(-90)")
                                .attr("y", -30)
                                .attr("x", -height / 2)
                                .attr("fill", axis.color || "#555")
                                .attr("font-size", spec.config.style?.axis?.labelFontSize || 11)
                                .attr("font-weight", spec.config.style?.axis?.labelFontWeight || "bold")
                                .attr("text-anchor", "middle")
                                .text(axis.label);
                        }
                    } else if (axis.position === 'right') {
                        const axR = g.append("g").attr("class", axisClass)
                            .attr("transform", `translate(${contentWidth}, 0)`)
                            .call(d3.axisRight(yScale).ticks(axis.ticks || 5));
                        
                        // Apply axis styles from config if no color specified
                        if (!colorClass && spec.config.style?.axis) {
                            axR.selectAll("text").attr("font-size", spec.config.style.axis.tickFontSize);
                            if (!axis.color) {
                                axR.selectAll("text").attr("fill", spec.config.style.axis.tickColor);
                                axR.selectAll("path, line").attr("stroke", spec.config.style.axis.domainColor);
                            }
                        }
                        
                        if (axis.label) {
                            axR.append("text").attr("class", "axis-label")
                                .attr("transform", "rotate(90)")
                                .attr("y", -30)
                                .attr("x", height / 2)
                                .attr("fill", axis.color || "#555")
                                .attr("font-size", spec.config.style?.axis?.labelFontSize || 11)
                                .attr("font-weight", spec.config.style?.axis?.labelFontWeight || "bold")
                                .attr("text-anchor", "middle")
                                .text(axis.label);
                        }
                    }
                });

                // Legend
                if (trackSpec.legend) {
                    const leg = g.append("g").attr("class", "legend").attr("transform", "translate(5,5)");
                    let offsetX = 0;
                    trackSpec.legend.items.forEach((item, i) => {
                        if (item.symbol === "v") {
                            const vWidth = 6;
                            const vHeight = 6;
                            const vPath = `M ${-vWidth},${-vHeight} L 0,0 L ${vWidth},${-vHeight}`;
                            leg.append("path").attr("d", vPath)
                                .attr("transform", `translate(${offsetX + 5},5)`)
                                .attr("fill", "none")
                                .attr("stroke", item.color)
                                .attr("stroke-width", 2);
                        } else if (item.symbol === "v-inv") {
                            const vWidth = 6;
                            const vHeight = 6;
                            const vPath = `M ${-vWidth},${vHeight} L 0,0 L ${vWidth},${vHeight}`;
                            leg.append("path").attr("d", vPath)
                                .attr("transform", `translate(${offsetX + 5},5)`)
                                .attr("fill", "none")
                                .attr("stroke", item.color)
                                .attr("stroke-width", 2);
                        } else if (item.symbol === "circle") {
                            leg.append("path").attr("d", d3.symbol().type(d3.symbolCircle).size(25))
                                .attr("transform", `translate(${offsetX + 5},5)`)
                                .attr("fill", "white")
                                .attr("stroke", item.color)
                                .attr("stroke-width", 2);
                        } else if (item.symbol === "circle-filled") {
                            leg.append("path").attr("d", d3.symbol().type(d3.symbolCircle).size(25))
                                .attr("transform", `translate(${offsetX + 5},5)`)
                                .attr("fill", item.color)
                                .attr("stroke", item.color)
                                .attr("stroke-width", 2);
                        }
                        const legendText = leg.append("text")
                            .attr("x", offsetX + 15)
                            .attr("y", 5)
                            .text(item.label);
                        
                        // Apply legend text styles from config
                        if (spec.config.style?.legend) {
                            legendText
                                .attr("font-size", spec.config.style.legend.fontSize)
                                .attr("fill", spec.config.style.legend.textColor)
                                .attr("alignment-baseline", "middle");
                        }
                        
                        offsetX += item.label.length * 6 + 55;
                    });
                }

                // Render series
                trackSpec.series.forEach(series => {
                    const yScale = scales[series.axis];
                    
                    // Constants for V-shape markers
                    const V_MARKER_WIDTH = 8;
                    const V_MARKER_HEIGHT = 6;
                    
                    if (series.type === 'line') {
                        const lineData = data[series.data];
                        const line = d3.line()
                            .x(d => x(d.time))
                            .y(d => yScale(d.value))
                            .curve(series.curve === 'monotoneX' ? d3.curveMonotoneX : d3.curveLinear);
                        
                        g.append("path")
                            .datum(lineData)
                            .attr("fill", "none")
                            .attr("stroke", series.color)
                            .attr("stroke-width", series.strokeWidth || 2)
                            .attr("stroke-dasharray", series.strokeDasharray || null)
                            .attr("d", line);
                        
                        if (series.showPoints) {
                            g.selectAll(`.dot-${series.data}`)
                                .data(lineData)
                                .enter()
                                .append("circle")
                                .attr("cx", d => x(d.time))
                                .attr("cy", d => yScale(d.value))
                                .attr("r", series.pointStyle?.radius || 3)
                                .attr("fill", series.pointStyle?.fill || "white")
                                .attr("stroke", series.pointStyle?.stroke || series.color)
                                .attr("stroke-width", series.pointStyle?.strokeWidth || 2);
                        }
                        
                        lineData.forEach(d => pushVoronoi(d.time, d.value, currentY, yScale, d, d.type));
                    } else if (series.type === 'point') {
                        const pointData = data[series.data];
                        
                        if (series.symbol === 'v') {
                            const vPath = `M ${-V_MARKER_WIDTH},${-V_MARKER_HEIGHT} L 0,0 L ${V_MARKER_WIDTH},${-V_MARKER_HEIGHT}`;
                            
                            g.selectAll(`.point-${series.data}`)
                                .data(pointData)
                                .enter()
                                .append("path")
                                .attr("d", vPath)
                                .attr("transform", d => `translate(${x(d.time)},${yScale(d.value)})`)
                                .attr("fill", "none")
                                .attr("stroke", series.color)
                                .attr("stroke-width", 2);
                            
                            // Draw connecting lines if connectTo is specified
                            if (series.connectTo) {
                                const connectData = data[series.connectTo];
                                // Build a map for O(1) lookups by timestamp
                                const connectMap = new Map(connectData.map(d => [d.time.getTime(), d]));
                                
                                pointData.forEach(sysPoint => {
                                    const diaPoint = connectMap.get(sysPoint.time.getTime());
                                    if (diaPoint) {
                                        g.append("line")
                                            .attr("x1", x(sysPoint.time))
                                            .attr("y1", yScale(sysPoint.value))
                                            .attr("x2", x(diaPoint.time))
                                            .attr("y2", yScale(diaPoint.value))
                                            .attr("stroke", "#999")
                                            .attr("stroke-width", 1)
                                            .attr("stroke-dasharray", "3,3");
                                    }
                                });
                            }
                        } else if (series.symbol === 'v-inv') {
                            const vInvPath = `M ${-V_MARKER_WIDTH},${V_MARKER_HEIGHT} L 0,0 L ${V_MARKER_WIDTH},${V_MARKER_HEIGHT}`;
                            
                            g.selectAll(`.point-${series.data}`)
                                .data(pointData)
                                .enter()
                                .append("path")
                                .attr("d", vInvPath)
                                .attr("transform", d => `translate(${x(d.time)},${yScale(d.value)})`)
                                .attr("fill", "none")
                                .attr("stroke", series.color)
                                .attr("stroke-width", 2);
                        } else if (series.symbol === 'circle') {
                            g.selectAll(`.point-${series.data}`)
                                .data(pointData)
                                .enter()
                                .append("path")
                                .attr("d", d3.symbol().type(d3.symbolCircle).size(30))
                                .attr("transform", d => `translate(${x(d.time)},${yScale(d.value)})`)
                                .attr("fill", series.hollow ? "white" : series.color)
                                .attr("stroke", series.color)
                                .attr("stroke-width", 2);
                        }
                        
                        pointData.forEach(d => pushVoronoi(d.time, d.value, currentY, yScale, d, d.type));
                    } else if (series.type === 'categorical') {
                        const catData = data[series.data];
                        const color = d3.scaleOrdinal()
                            .domain(series.colorScale.domain)
                            .range(series.colorScale.range);
                        const bandHeight = Math.abs(yScale(1) - yScale(2)) * 0.8;
                        
                        g.selectAll(".cat")
                            .data(catData)
                            .enter()
                            .append("rect")
                            .attr("x", d => x(d.time) - series.barWidth / 2)
                            .attr("y", d => yScale(d.value) - bandHeight / 2)
                            .attr("width", series.barWidth)
                            .attr("height", bandHeight)
                            .attr("fill", d => color(d.value))
                            .attr("rx", series.barRadius);
                        
                        catData.forEach(d => pushVoronoi(d.time, d.value, currentY, yScale, d, d.type));
                    }
                });

                currentY += height + trackGaps;
            });

            // --- X Axis (from mockup) ---
            const axisY = currentY + axisGap;
            svg.append("line").attr("x1", 0).attr("y1", axisY).attr("x2", contentWidth).attr("y2", axisY).attr("stroke", "#ddd");
            const xAxisG = svg.append("g").attr("transform", `translate(0, ${axisY})`).attr("class", "axis");
            const hourlyTicks = x.ticks(d3.timeHour.every(1));

            const tg = xAxisG.selectAll(".tick-label").data(hourlyTicks).enter().append("g").attr("transform", d => `translate(${x(d)}, 0)`);
            tg.append("line").attr("y1", 0).attr("y2", 5).attr("stroke", "#ddd");
            
            tg.each(function (d) {
                if (d.getHours() % 3 === 0) {
                    d3.select(this).append("text")
                        .attr("text-anchor", "middle").attr("y", 15).attr("font-size", "10px").attr("fill", "#444")
                        .text(d3.timeFormat("%H:%M")(d));
                }
            });

            // Date Labels (Midnight & Sticky Left)
            const dateStr = d3.timeFormat("%a %Y-%m-%d");
            let stickyNeeded = true;
            tg.each(function (d) {
                if (d.getHours() === 0) {
                    stickyNeeded = x(d) > 80;
                    const w = 100;
                    const g = d3.select(this).append("g").attr("transform", `translate(0, 18)`);
                    const lineBottom = fullHeight - margin.top - (axisY + 18);
                    g.append("line")
                        .attr("x1", 0).attr("y1", -12)
                        .attr("x2", 0).attr("y2", lineBottom)
                        .attr("stroke", "#ddd").attr("stroke-width", 1);

                    const arrowPath = `M0,0 L${w - 10},0 L${w},9 L${w - 10},18 L0,18 Z`;
                    g.append("path").attr("d", arrowPath).attr("fill", "#eef").style("stroke", "none");
                    g.append("text").attr("x", 5).attr("y", 12).attr("font-size", "10px").attr("fill", "#446").attr("font-weight", "bold").text(dateStr(d));

                    if (x(d) < w + 10) stickyNeeded = false;
                }
            });

            if (stickyNeeded) {
                const startD = x.domain()[0];
                const stickyG = xAxisG.append("g").attr("transform", `translate(0, 18)`);
                const w = 100;
                const arrowPathFixed = `M0,0 L${w - 10},0 L${w},9 L${w - 10},18 L0,18 Z`;
                stickyG.append("path").attr("d", arrowPathFixed).attr("fill", "url(#fade-left)").style("stroke", "none");
                stickyG.append("text").attr("x", 5).attr("y", 12).attr("font-size", "10px").attr("fill", "#446").attr("font-weight", "bold").text(dateStr(startD));
                stickyG.lower();
            }

            // --- Crosshair ---
            const crosshair = svg.append("line")
                .attr("class", "crosshair")
                .attr("y1", 0)
                .attr("y2", axisY);
            
            // Apply crosshair styles from config
            if (spec.config.style?.crosshair) {
                crosshair
                    .attr("stroke", spec.config.style.crosshair.stroke)
                    .attr("stroke-width", spec.config.style.crosshair.strokeWidth)
                    .attr("stroke-dasharray", spec.config.style.crosshair.strokeDasharray);
            }

            // --- Voronoi Interaction (from mockup) ---
            const delaunay = d3.Delaunay.from(voronoiPoints, d => d.x, d => d.y);
            const tooltip = d3.select("#tooltip");
            
            // Apply tooltip styles from config
            if (spec.config.style?.tooltip) {
                tooltip
                    .style("padding", spec.config.style.tooltip.padding + "px")
                    .style("font-size", spec.config.style.tooltip.fontSize + "px")
                    .style("background", spec.config.style.tooltip.background)
                    .style("color", spec.config.style.tooltip.textColor)
                    .style("border-radius", spec.config.style.tooltip.borderRadius + "px");
            }
            
            const highlighter = svg.append("circle").attr("r", 8).attr("fill", "none").attr("stroke", "#333").attr("stroke-width", 2).attr("stroke-opacity", 0.5).style("opacity", 0).style("pointer-events", "none");

            svg.append("rect")
                .attr("width", contentWidth)
                .attr("height", axisY)
                .attr("fill", "transparent")
                .on("mousemove", (event) => {
                    const [mx, my] = d3.pointer(event);
                    crosshair.attr("x1", mx).attr("x2", mx).style("opacity", 0.8);

                    const index = delaunay.find(mx, my);
                    if (index !== null) {
                        const d = voronoiPoints[index];
                        if (Math.hypot(mx - d.x, my - d.y) < 50) {
                            highlighter.attr("cx", d.x).attr("cy", d.y).style("opacity", 1);

                            const bounds = document.getElementById("chart-container").getBoundingClientRect();
                            const absX = bounds.left + margin.left + d.x;
                            const absY = bounds.top + margin.top + d.y;
                            let valStr = typeof d.data.value === 'number' ? d.data.value.toFixed(d.label === 'Wellbeing' ? 0 : 1) : d.data.value;

                            tooltip.style("opacity", 0.95)
                                .html(`<strong>${d.label}</strong><br>${formatFullTime(d.time)}<br>${valStr} ${d.data.unit}`)
                                .style("left", (absX + 15) + "px")
                                .style("top", (absY - 28) + "px");
                        } else {
                            highlighter.style("opacity", 0);
                            tooltip.style("opacity", 0);
                        }
                    }
                })
                .on("mouseleave", () => {
                    highlighter.style("opacity", 0);
                    tooltip.style("opacity", 0);
                    crosshair.style("opacity", 0);
                });
        }

        // --- Resize Observer (from mockup) ---
        const container = document.getElementById('chart-container');
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                if (width > 0 && height > 0) {
                    renderChart(width, height);
                }
            }
        });
        resizeObserver.observe(container);
    </script>
</body>
</html>
